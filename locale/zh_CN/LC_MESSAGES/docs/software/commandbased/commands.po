# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, FIRST and other WPILib Contributors. This work is licensed under a Creative Commons Attribution 4.0 International License
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jiangshan Gong <jiangshan_gong@163.com>, 2020
# Yitong Zhao <lucius300er@outlook.com>, 2021
# Team 5308 <team5308@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2022\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-10 04:35+0000\n"
"PO-Revision-Date: 2020-04-25 02:02+0000\n"
"Last-Translator: Team 5308 <team5308@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/wpilib/teams/109324/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:2
msgid "Commands"
msgstr "指令"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:7
msgid "Creating Commands"
msgstr "创建指令"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:31
msgid ""
"As before, this contains several convenience features. It automatically "
"overrides the ``getRequirements()`` method for users, returning a list of "
"requirements that is empty by default, but can be added to with the "
"``addRequirements()`` method. It also implements the ``Sendable`` interface,"
" and so can be sent to the dashboard - this provides a handy way for "
"scheduling commands for testing (via a button on the dashboard) without "
"needing to bind them to buttons on a controller."
msgstr ""
"和以前一样，它包含一些便利功能。它会自动为用户覆盖“getRequirements()”方法，返回默认情况下为空的需求列表，但可以使用“addRequirements()”方法添加到其中。它还实现了“Sendable”接口，因此可以发送到仪表板——这提供了一种方便的方式来安调度排测试指令（通过仪表板上的按钮），而无需将其绑定到控制器上的按钮。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:34
msgid ""
"Also as before, advanced users seeking more flexibility are free to simply "
"create their own class implementing the ``Command`` interface."
msgstr "同样，像以前一样，寻求更高灵活性的高级用户可以自由地创建自己的类来实现“Command”接口。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:37
msgid "The Structure of a Command"
msgstr "指令的结构"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:39
msgid ""
"While subsystems are fairly freeform, and may generally look like whatever "
"the user wishes them to, commands are quite a bit more constrained. Command "
"code must specify what the command will do in each of its possible states. "
"This is done by overriding the ``initialize()``, ``execute()``, and "
"``end()`` methods. Additionally, a command must be able to tell the "
"scheduler when (if ever) it has finished execution - this is done by "
"overriding the ``isFinished()`` method. All of these methods are defaulted "
"to reduce clutter in user code: ``initialize()``, ``execute()``, and "
"``end()`` are defaulted to simply do nothing, while ``isFinished()`` is "
"defaulted to return false (resulting in a command that never ends)."
msgstr ""
"尽管子系统是相当自由的形式，并且通常看起来像用户希望它们具有的功能，但是指令的约束要多得多。指令的代码必须指定指令在每种可能的状态下将执行的操作。这是通过覆盖“initialize()”，“execute()”和“end()”方法来完成的。另外，指令必须能够告诉调度程序何时（如果有）完成执行——通过重写“isFinished()”方法来完成。所有这些方法默认情况下都是为了减少用户代码中的混乱：“initialize()”，“execute()”和“end()”默认情况下只是不执行任何操作，而“isFinished()”"
" 默认返回false（导致一个永不停止的命令）。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:42
msgid "Initialization"
msgstr "初始化"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:47
msgid "Execution"
msgstr "执行"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:52
msgid "Ending"
msgstr "结束"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:57
msgid "Specifying end conditions"
msgstr "指定结束条件"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:62
msgid "Simple Command Example"
msgstr "简单的指令示例"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:64
msgid ""
"What might a functional command look like in practice? As before, below is a"
" simple command from the HatchBot example project (`Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__)"
" that uses the ``HatchSubsystem`` introduced in the previous section:"
msgstr ""
"实际上，功能命令是什么样的？和以前一样，下面是HatchBot示例项目（Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__，`C"
" ++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__）中的简单命令，该命令使用了上一节中介绍的“"
" HatchSubsystem”："

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:96
msgid ""
"What about a more complicated case? Below is a drive command, from the same "
"example project:"
msgstr "那更复杂的情况呢？以下是来自同一示例项目的驱动指令："

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, FIRST and other WPILib Contributors
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jiangshan Gong <jiangshan_gong@163.com>, 2020
# Yitong Zhao <lucius300er@outlook.com>, 2021
# Team 5308 <team5308@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-18 04:03+0000\n"
"PO-Revision-Date: 2020-04-25 02:02+0000\n"
"Last-Translator: Team 5308 <team5308@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/wpilib/teams/109324/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:2
msgid "Commands"
msgstr "指令"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:4
msgid ""
"Commands are simple state machines that perform high-level robot functions "
"using the methods defined by subsystems. Commands can be either idle, in "
"which they do nothing, or scheduled, in which the scheduler will execute a "
"specific set of the command’s code depending on the state of the command. "
"The ``CommandScheduler`` recognizes scheduled commands as being in one of "
"three states: initializing, executing, or ending. Commands specify what is "
"done in each of these states through the ``initialize()``, ``execute()`` and"
" ``end()`` methods.  Commands are represented in the command-based library "
"by the ``Command`` interface (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html>`__)."
msgstr ""
"命令是简单的状态机，使用子系统定义的方法执行高级机器人功能。命令可以是空闲的(不执行任何操作)，也可以是已调度的(在调度中，调度程序将根据命令的状态执行一组特定的命令代码)。"
" "
"CommandScheduler``将调度的命令识别为处于以下三种状态之一：初始化，执行或结束。命令通过``initialize()''，``execute()''和``end()''方法指定在每种状态下要执行的操作。命令在基于命令的库中由“命令”接口(Java"
" "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html>`"
" __，`C ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html>`__)表示。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:7
msgid "Creating Commands"
msgstr "创建指令"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:9
msgid ""
"In the C++ API, a `CRTP "
"<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`__ is "
"used to allow certain Command methods to work with the object ownership "
"model.  Users should *always* extend the ``CommandHelper`` `class "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibNewCommands/src/main/native/include/frc2/command/CommandHelper.h>`__"
" when defining their own command classes, as is shown below."
msgstr ""
"在C ++ API中，`CRTP "
"<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`__用于允许某些Command方法与对象所有权模型一起使用。用户在定义自己的命令类时，应*始终*扩展CommandHelper类<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibNewCommands/src/main/native/include/frc2/command/CommandHelper.h>`__，如下所示。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:11
msgid ""
"Similarly to subsystems, the recommended method for most users to create a "
"command is to subclass the abstract ``CommandBase`` class (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/CommandBase.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1CommandBase.html>`__),"
" as seen in the command-based template (`Java "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/templates/commandbased/commands/ExampleCommand.java>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibcExamples/src/main/cpp/templates/commandbased/include/commands/ExampleCommand.h>`__):"
msgstr ""
"与子系统类似，建议大多数用户创建命令的方法是将抽象的CommandBase类（Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/CommandBase.html>`__，`C"
" ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1CommandBase.html>`__）子类化，如在基于命令的模板（Java）中所见。"
" "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/templates/commandbased/commands/ExampleCommand.java>`__，`C"
" ++ "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibcExamples/src/main/cpp/templates/commandbased/include/commands/ExampleCommand.h>`__）："

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:31
msgid ""
"As before, this contains several convenience features. It automatically "
"overrides the ``getRequirements()`` method for users, returning a list of "
"requirements that is empty by default, but can be added to with the "
"``addRequirements()`` method. It also implements the ``Sendable`` interface,"
" and so can be sent to the dashboard - this provides a handy way for "
"scheduling commands for testing (via a button on the dashboard) without "
"needing to bind them to buttons on a controller."
msgstr ""
"和以前一样，它包含一些便利功能。它会自动为用户覆盖“getRequirements()”方法，返回默认情况下为空的需求列表，但可以使用“addRequirements()”方法添加到其中。它还实现了“Sendable”接口，因此可以发送到仪表板——这提供了一种方便的方式来安调度排测试指令（通过仪表板上的按钮），而无需将其绑定到控制器上的按钮。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:34
msgid ""
"Also as before, advanced users seeking more flexibility are free to simply "
"create their own class implementing the ``Command`` interface."
msgstr "同样，像以前一样，寻求更高灵活性的高级用户可以自由地创建自己的类来实现“Command”接口。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:37
msgid "The Structure of a Command"
msgstr "指令的结构"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:39
msgid ""
"While subsystems are fairly freeform, and may generally look like whatever "
"the user wishes them to, commands are quite a bit more constrained. Command "
"code must specify what the command will do in each of its possible states. "
"This is done by overriding the ``initialize()``, ``execute()``, and "
"``end()`` methods. Additionally, a command must be able to tell the "
"scheduler when (if ever) it has finished execution - this is done by "
"overriding the ``isFinished()`` method. All of these methods are defaulted "
"to reduce clutter in user code: ``initialize()``, ``execute()``, and "
"``end()`` are defaulted to simply do nothing, while ``isFinished()`` is "
"defaulted to return false (resulting in a command that never ends)."
msgstr ""
"尽管子系统是相当自由的形式，并且通常看起来像用户希望它们具有的功能，但是指令的约束要多得多。指令的代码必须指定指令在每种可能的状态下将执行的操作。这是通过覆盖“initialize()”，“execute()”和“end()”方法来完成的。另外，指令必须能够告诉调度程序何时（如果有）完成执行——通过重写“isFinished()”方法来完成。所有这些方法默认情况下都是为了减少用户代码中的混乱：“initialize()”，“execute()”和“end()”默认情况下只是不执行任何操作，而“isFinished()”"
" 默认返回false（导致一个永不停止的命令）。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:42
msgid "Initialization"
msgstr "初始化"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:44
msgid ""
"The ``initialize()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#initialize()>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#ad3f1971a1b44ecdd4683d766f831bccd>`__)"
" is run exactly once per time a command is scheduled, as part of the "
"scheduler’s ``schedule()`` method. The scheduler’s ``run()`` method does not"
" need to be called for the ``initialize()`` method to run. The initialize "
"block should be used to place the command in a known starting state for "
"execution. It is also useful for performing tasks that only need to be "
"performed once per time scheduled, such as setting motors to run at a "
"constant speed or setting the state of a solenoid actuator."
msgstr ""
"每次调度命令时，initialize（）方法（Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#initialize()>`__，`C"
" ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#ad3f1971a1b44ecdd4683d766f831bccd>`__）仅运行一次，这是调度程序schedule（）方法的一部分。无需调用调度程序的run（）方法即可运行initialize（）方法。应该使用initialize块将命令置于已知的开始状态以执行。这对于执行每个计划时间仅需要执行一次的任务（例如，将电动机设置为以恒定速度运行或设置螺线管致动器的状态）也很有用。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:47
msgid "Execution"
msgstr "执行"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:49
msgid ""
"The ``execute()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#execute()>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#a7d7ea1271f7dcc65c0ba3221d179b510>`__)"
" is called repeatedly while the command is scheduled, whenever the "
"scheduler’s ``run()`` method is called (this is generally done in the main "
"robot periodic method, which runs every 20ms by default). The execute block "
"should be used for any task that needs to be done continually while the "
"command is scheduled, such as updating motor outputs to match joystick "
"inputs, or using the output of a control loop."
msgstr ""
"每次调用调度程序的run（）方法时，都会在调度命令时反复调用execute（）方法（Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#execute()>"
" __，C ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#a7d7ea1271f7dcc65c0ba3221d179b510>`"
" "
"__）（通常在主机器人周期性方法，默认情况下每20ms运行一次）。执行块应用于在计划命令时需要连续完成的任何任务，例如更新电动机输出以匹配操纵杆输入，或使用控制回路的输出。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:52
msgid "Ending"
msgstr "结束"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:54
msgid ""
"The ``end()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#end(boolean)>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#a134eda3756f00c667bb5415b23ee920c>`__)"
" is called once when the command ends, whether it finishes normally (i.e. "
"``isFinished()`` returned true) or it was interrupted (either by another "
"command or by being explicitly canceled). The method argument specifies the "
"manner in which the command ended; users can use this to differentiate the "
"behavior of their command end accordingly. The end block should be used to "
"\"wrap up\" command state in a neat way, such as setting motors back to zero"
" or reverting a solenoid actuator to a \"default\" state."
msgstr ""
"命令结束后，无论是否正常完成（例如isFinished（）返回true）或被中断，都会调用一次end（）方法（Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#end(boolean)>`"
" __，C ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#a134eda3756f00c667bb5415b23ee920c>`__）"
" （通过另一个命令或被显式取消）。 "
"method参数指定命令结束的方式。用户可以使用它来相应地区分其命令端的行为。端块应以整洁的方式“整理”命令状态，例如将电动机设置为零或将螺线管执行器恢复为“默认”状态。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:57
msgid "Specifying end conditions"
msgstr "指定结束条件"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:59
msgid ""
"The ``isFinished()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#end(boolean)>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#af5e8c12152d195a4f3c06789366aac88>`__)"
" is called repeatedly while the command is scheduled, whenever the "
"scheduler’s ``run()`` method is called. As soon as it returns true, the "
"command’s ``end()`` method is called and it is un-scheduled. The "
"``isFinished()`` method is called *after* the ``execute()`` method, so the "
"command *will* execute once on the same iteration that it is un-scheduled."
msgstr ""
"每当调用调度程序的run（）方法时，就会在调度命令时重复调用isFinished（）方法（Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#end(boolean)>"
" __，C ++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#af5e8c12152d195a4f3c06789366aac88>"
" __）。一旦返回true，就会调用命令的end（）方法，并且该方法是非计划的。 "
"isFinished（）方法在execute（）方法之后被调用，因此命令将在未计划的同一迭代中执行一次。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:62
msgid "Simple Command Example"
msgstr "简单的指令示例"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:64
msgid ""
"What might a functional command look like in practice? As before, below is a"
" simple command from the HatchBot example project (`Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__)"
" that uses the ``HatchSubsystem`` introduced in the previous section:"
msgstr ""
"实际上，功能命令是什么样的？和以前一样，下面是HatchBot示例项目（Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__，`C"
" ++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__）中的简单命令，该命令使用了上一节中介绍的“"
" HatchSubsystem”："

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:92
msgid ""
"Notice that the hatch subsystem used by the command is passed into the "
"command through the command’s constructor. This is a pattern called "
"`dependency injection "
"<https://en.wikipedia.org/wiki/Dependency_injection>`__, and allows users to"
" avoid declaring their subsystems as global variables. This is widely "
"accepted as a best-practice - the reasoning behind this is discussed in a "
":doc:`later section <structuring-command-based-project>`."
msgstr ""
"请注意，该指令所使用的图案填充子系统是通过指令的构造函数传递到指令中的。这种模式称为`dependency injection "
"<https://en.wikipedia.org/wiki/Dependency_injection>`__，并且允许用户避免将其子系统声明为全局变量。最佳做法已被广泛接受——其背后的论证在:doc:`later"
" section <structuring-command-based-project>`中讨论。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:94
msgid ""
"Notice also that the above command calls the subsystem method once from "
"initialize, and then immediately ends (as ``isFinished()`` simply returns "
"true). This is typical for commands that toggle the states of subsystems, "
"and in fact the command-based library includes code to make :ref:`commands "
"like this <docs/software/commandbased/convenience-features:InstantCommand>` "
"even more succinctly."
msgstr ""
"还要注意，以上指令从初始化调用一次子系统方法，然后立即结束（因为“isFinished()”仅返回true）。这对于切换子系统状态的命令来说是典型的，实际上基于命令的库包含使诸如此类:ref:`commands"
" like this <docs/software/commandbased/convenience-features:InstantCommand>`"
" 指令的代码更加简洁的代码。"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:96
msgid ""
"What about a more complicated case? Below is a drive command, from the same "
"example project:"
msgstr "那更复杂的情况呢？以下是来自同一示例项目的驱动指令："

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:124
msgid ""
"Notice that this command does not override ``isFinished()``, and thus will "
"never end; this is the norm for commands that are intended to be used as "
"default commands (and, as can be guessed, the library includes tools to make"
" :ref:`this kind of command <docs/software/commandbased/convenience-"
"features:RunCommand>` easier to write, too!)."
msgstr ""
"注意，该指令不会覆盖“isFinished()”，因此它永远不会结束；这是旨在用作默认指令的指令的规范（而且，可以猜到，该库包含一些工具，这些工具也使:ref:`this"
" kind of command <docs/software/commandbased/convenience-"
"features:RunCommand>` 更加易于编写！）。"

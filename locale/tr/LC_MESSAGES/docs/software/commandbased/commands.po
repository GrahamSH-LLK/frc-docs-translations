# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, FIRST and other WPILib Contributors
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Esra ÖZEMRE <esra.ozemre@tfo.k12.tr>, 2020
# Hasan Bilgin <hasanbilgin@fikretyukselfoundation.org>, 2021
# Müfit ALKAYA <mufit.alkaya@tfo.k12.tr>, 2021
# ceren oktemer <ceren.oktemer@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-18 04:03+0000\n"
"PO-Revision-Date: 2020-04-25 02:02+0000\n"
"Last-Translator: ceren oktemer <ceren.oktemer@gmail.com>, 2021\n"
"Language-Team: Turkish (Turkey) (https://www.transifex.com/wpilib/teams/109324/tr_TR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: tr_TR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:2
msgid "Commands"
msgstr "Komutlar"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:4
msgid ""
"Commands are simple state machines that perform high-level robot functions "
"using the methods defined by subsystems. Commands can be either idle, in "
"which they do nothing, or scheduled, in which the scheduler will execute a "
"specific set of the command’s code depending on the state of the command. "
"The ``CommandScheduler`` recognizes scheduled commands as being in one of "
"three states: initializing, executing, or ending. Commands specify what is "
"done in each of these states through the ``initialize()``, ``execute()`` and"
" ``end()`` methods.  Commands are represented in the command-based library "
"by the ``Command`` interface (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html>`__)."
msgstr ""
"Komutlar, alt sistemler tarafından tanımlanan yöntemleri kullanarak üst "
"düzey robot işlevlerini gerçekleştiren basit durum makineleridir. Komutlar, "
"içinde hiçbir şey yapmadıkları boşta olabilir veya programlayıcının komutun "
"durumuna bağlı olarak komutun kodunun belirli bir kümesini yürüteceği "
"zamanlanmış olabilir. ``CommandScheduler``, planlanan komutları şu üç "
"durumdan birinde olarak tanır: başlatma, yürütme veya sonlandırma. Komutlar,"
" bu durumların her birinde ``initialize()``, ``execute()`` ve ``end()`` "
"methodları aracılığıyla ne yapıldığını belirtir. Komutlar, komut tabanlı "
"kitaplıkta ``Command`` interface (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html>`__)."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:7
msgid "Creating Commands"
msgstr "Komutlar Oluşturma"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:9
msgid ""
"In the C++ API, a `CRTP "
"<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`__ is "
"used to allow certain Command methods to work with the object ownership "
"model.  Users should *always* extend the ``CommandHelper`` `class "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibNewCommands/src/main/native/include/frc2/command/CommandHelper.h>`__"
" when defining their own command classes, as is shown below."
msgstr ""
"C ++ API'sinde, belirli Command yöntemlerinin nesne sahipliği modeliyle "
"çalışmasına izin vermek için bir `CRTP "
"<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>` __ "
"kullanılır. Kullanıcılar, aşağıda gösterildiği gibi, kendi komut sınıflarını"
" tanımlarken * her zaman * ``CommandHelper`` `sınıf "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibNewCommands/src/main/native/include/frc2/command/CommandHelper.h>`__"
" genişletmelidir."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:11
msgid ""
"Similarly to subsystems, the recommended method for most users to create a "
"command is to subclass the abstract ``CommandBase`` class (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/CommandBase.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1CommandBase.html>`__),"
" as seen in the command-based template (`Java "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/templates/commandbased/commands/ExampleCommand.java>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibcExamples/src/main/cpp/templates/commandbased/include/commands/ExampleCommand.h>`__):"
msgstr ""
"Alt sistemlere benzer şekilde, çoğu kullanıcının bir komut oluşturması için "
"önerilen yöntem, soyut \" CommandBase`` sınıfını alt sınıflara ayırmaktır. "
"(`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/CommandBase.html>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1CommandBase.html>`__),"
" as seen in the command-based template (`Java "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/templates/commandbased/commands/ExampleCommand.java>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/blob/main/wpilibcExamples/src/main/cpp/templates/commandbased/include/commands/ExampleCommand.h>`__):"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:31
msgid ""
"As before, this contains several convenience features. It automatically "
"overrides the ``getRequirements()`` method for users, returning a list of "
"requirements that is empty by default, but can be added to with the "
"``addRequirements()`` method. It also implements the ``Sendable`` interface,"
" and so can be sent to the dashboard - this provides a handy way for "
"scheduling commands for testing (via a button on the dashboard) without "
"needing to bind them to buttons on a controller."
msgstr ""
"Daha önce olduğu gibi, bu birkaç kolaylık içerir. Kullanıcılar için "
"``getRequirements ()`` yöntemini otomatik olarak geçersiz kılarak, "
"varsayılan olarak boş olan ancak ``addRequirements()`` ' yöntemiyle "
"eklenebilen bir gereksinim listesi döndürür. Aynı zamanda ``Sendable`` "
"arayüzünü de uygular ve böylece kontrol paneline gönderilebilir - bu, "
"komutları bir denetleyicideki düğmelere bağlamaya gerek kalmadan test için "
"(kontrol panelindeki bir düğme aracılığıyla) programlamak için kullanışlı "
"bir yol sağlar."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:34
msgid ""
"Also as before, advanced users seeking more flexibility are free to simply "
"create their own class implementing the ``Command`` interface."
msgstr ""
"Ayrıca daha önce olduğu gibi, daha fazla esneklik arayan ileri düzey "
"kullanıcılar, ``Command`` arayüzünü uygulayarak kendi sınıflarını "
"oluşturmakta özgürdür."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:37
msgid "The Structure of a Command"
msgstr "Bir Komutun Yapısı"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:39
msgid ""
"While subsystems are fairly freeform, and may generally look like whatever "
"the user wishes them to, commands are quite a bit more constrained. Command "
"code must specify what the command will do in each of its possible states. "
"This is done by overriding the ``initialize()``, ``execute()``, and "
"``end()`` methods. Additionally, a command must be able to tell the "
"scheduler when (if ever) it has finished execution - this is done by "
"overriding the ``isFinished()`` method. All of these methods are defaulted "
"to reduce clutter in user code: ``initialize()``, ``execute()``, and "
"``end()`` are defaulted to simply do nothing, while ``isFinished()`` is "
"defaulted to return false (resulting in a command that never ends)."
msgstr ""
"Alt sistemler oldukça serbest biçimliyken ve genellikle kullanıcının "
"istediği gibi görünse de, komutlar biraz daha kısıtlıdır. Komut kodu, "
"komutun olası durumlarının her birinde ne yapacağını belirtmelidir. Bu, "
"``initialize()``, ``execute()`` ve ``end()`` yöntemlerini geçersiz kılarak "
"yapılır. Ek olarak, bir komut zamanlayıcıya yürütmeyi ne zaman bitirdiğini "
"(eğer varsa) söyleyebilmelidir - bu, ``isFinished()`` yöntemini geçersiz "
"kılarak yapılır. Bu yöntemlerin tümü varsayılan olarak kullanıcı kodundaki "
"dağınıklığı azaltmak için ayarlanmıştır: ``initialize()``, ``execute()`` ve "
"``end()`` varsayılan olarak hiçbir şey yapmazken, ``isFinished()`` "
"varsayılan olarak false döndürür (hiç bitmeyen bir komutla sonuçlanır)."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:42
msgid "Initialization"
msgstr "Initialization - Başlatma"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:44
msgid ""
"The ``initialize()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#initialize()>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#ad3f1971a1b44ecdd4683d766f831bccd>`__)"
" is run exactly once per time a command is scheduled, as part of the "
"scheduler’s ``schedule()`` method. The scheduler’s ``run()`` method does not"
" need to be called for the ``initialize()`` method to run. The initialize "
"block should be used to place the command in a known starting state for "
"execution. It is also useful for performing tasks that only need to be "
"performed once per time scheduled, such as setting motors to run at a "
"constant speed or setting the state of a solenoid actuator."
msgstr ""
"``initialize()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#initialize()>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#ad3f1971a1b44ecdd4683d766f831bccd>`__)"
" , zamanlayıcının ``schedule()`` methodunun bir parçası olarak, bir komut "
"zamanlandığında tam olarak bir kez çalıştırılır. Planlayıcının ``run()`` "
"yönteminin, ``initialize()`` yönteminin çalışması için çağrılmasına gerek "
"yoktur. Başlatma bloğu, komutu yürütme için bilinen bir başlangıç durumuna "
"yerleştirmek için kullanılmalıdır. Motorları sabit bir hızda çalışacak "
"şekilde ayarlamak veya bir solenoid aktüatörün durumunu ayarlamak gibi "
"programlanan zamanda yalnızca bir kez gerçekleştirilmesi gereken görevleri "
"gerçekleştirmek için de kullanışlıdır."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:47
msgid "Execution"
msgstr "Execution - Yürütme"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:49
msgid ""
"The ``execute()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#execute()>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#a7d7ea1271f7dcc65c0ba3221d179b510>`__)"
" is called repeatedly while the command is scheduled, whenever the "
"scheduler’s ``run()`` method is called (this is generally done in the main "
"robot periodic method, which runs every 20ms by default). The execute block "
"should be used for any task that needs to be done continually while the "
"command is scheduled, such as updating motor outputs to match joystick "
"inputs, or using the output of a control loop."
msgstr ""
"``execute()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#execute()>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#a7d7ea1271f7dcc65c0ba3221d179b510>`__),"
" zamanlayıcının ``run()`` yöntemi çağrıldığında, komut zamanlanırken tekrar "
"tekrar çağrılır (bu genellikle varsayılan olarak her 20 ms'de bir çalışan "
"ana robot periyodik yöntemi). Yürütme bloğu, motor çıkışlarını kumanda kolu "
"girişleriyle eşleşecek şekilde güncelleme veya bir kontrol döngüsünün "
"çıkışını kullanma gibi komut programlanırken sürekli olarak yapılması "
"gereken herhangi bir görev için kullanılmalıdır."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:52
msgid "Ending"
msgstr "Ending - Bitirme"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:57
msgid "Specifying end conditions"
msgstr "Bitiş-end koşullarını belirleme"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:59
msgid ""
"The ``isFinished()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#end(boolean)>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#af5e8c12152d195a4f3c06789366aac88>`__)"
" is called repeatedly while the command is scheduled, whenever the "
"scheduler’s ``run()`` method is called. As soon as it returns true, the "
"command’s ``end()`` method is called and it is un-scheduled. The "
"``isFinished()`` method is called *after* the ``execute()`` method, so the "
"command *will* execute once on the same iteration that it is un-scheduled."
msgstr ""
"``isFinished()`` method (`Java "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html#end(boolean)>`__,"
" `C++ "
"<https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/classfrc2_1_1Command.html#af5e8c12152d195a4f3c06789366aac88>`__),"
"  zamanlayıcının  ``run()``  methodu her çağrıldığında, komut zamanlanırken "
"tekrar tekrar çağrılır. True döndürür döndürmez, komutun ``end()``  yöntemi "
"çağrılır ve planlanmamış olur. `` İsFinished () '' yöntemi, ``execute()`` "
"yönteminden *after-sonra* çağrılır, bu nedenle komut, *zamanlanmamış* olduğu"
" aynı yinelemede bir kez çalıştırılacaktır."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:62
msgid "Simple Command Example"
msgstr "Basit Komut Örneği"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:64
msgid ""
"What might a functional command look like in practice? As before, below is a"
" simple command from the HatchBot example project (`Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__)"
" that uses the ``HatchSubsystem`` introduced in the previous section:"
msgstr ""
"Pratikte işlevsel bir komut neye benzeyebilir? Daha önce olduğu gibi, "
"aşağıda önceki bölümde tanıtılan \" HatchSubsystem '' i kullanan HatchBot "
"örnek projesinden (`Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`"
" __, `C ++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`"
" __) basit bir komut verilmiştir:"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:92
msgid ""
"Notice that the hatch subsystem used by the command is passed into the "
"command through the command’s constructor. This is a pattern called "
"`dependency injection "
"<https://en.wikipedia.org/wiki/Dependency_injection>`__, and allows users to"
" avoid declaring their subsystems as global variables. This is widely "
"accepted as a best-practice - the reasoning behind this is discussed in a "
":doc:`later section <structuring-command-based-project>`."
msgstr ""
"Komut tarafından kullanılan tarama alt sisteminin komutun constructor "
"aracılığıyla komuta aktarıldığına dikkat edin. Bu, `bağımlılık enjeksiyonu "
"<https://en.wikipedia.org/wiki/Dependency_injection>`__ adı verilen bir "
"kalıptır ve kullanıcıların alt sistemlerini genel değişkenler olarak "
"bildirmekten kaçınmalarına olanak tanır. Bu yaygın bir şekilde en iyi "
"uygulama olarak kabul edilmektedir - bunun arkasındaki mantık :doc:`sonraki "
"bölüm <structuring-command-based-project> 'da tartışılmaktadır."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:94
msgid ""
"Notice also that the above command calls the subsystem method once from "
"initialize, and then immediately ends (as ``isFinished()`` simply returns "
"true). This is typical for commands that toggle the states of subsystems, "
"and in fact the command-based library includes code to make :ref:`commands "
"like this <docs/software/commandbased/convenience-features:InstantCommand>` "
"even more succinctly."
msgstr ""
"Ayrıca yukarıdaki komutun alt sistem yöntemini bir kez başlatıldıktan sonra "
"çağırdığına ve ardından hemen sona erdiğine dikkat edin (``isFinished()`` "
"basitçe true döndürür). Bu, alt sistemlerin durumlarını değiştiren komutlar "
"için tipiktir ve aslında komuta dayalı kitaplık yapmak için kod içerir "
":ref:`bunun gibi daha da özlü komutlar <docs/software/commandbased"
"/convenience-features:InstantCommand>` ."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:96
msgid ""
"What about a more complicated case? Below is a drive command, from the same "
"example project:"
msgstr ""
"Daha karmaşık bir vakaya ne dersiniz? Aşağıda aynı örnek projeden bir sürücü"
" komutu verilmiştir:"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:124
msgid ""
"Notice that this command does not override ``isFinished()``, and thus will "
"never end; this is the norm for commands that are intended to be used as "
"default commands (and, as can be guessed, the library includes tools to make"
" :ref:`this kind of command <docs/software/commandbased/convenience-"
"features:RunCommand>` easier to write, too!)."
msgstr ""
"Bu komutun ``isFinished()`` yi geçersiz kılmadığına ve bu nedenle asla sona "
"ermeyeceğine dikkat edin; bu, varsayılan komutlar olarak kullanılması "
"amaçlanan komutlar için bir normdur (ve tahmin edilebileceği gibi, kütüphane"
" şunları yapacak araçları içerir :ref:`bu tür bir komut "
"<docs/software/commandbased/convenience-features:RunCommand>` yazması daha "
"kolay!)."
